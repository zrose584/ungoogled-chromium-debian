description: use inspector_protocol from top level third_party dir
author: Michael Gilbert <mgilbert@debian.org>

--- a/v8/src/inspector/BUILD.gn
+++ b/v8/src/inspector/BUILD.gn
@@ -4,7 +4,7 @@
 
 import("../../gni/v8.gni")
 
-_inspector_protocol = v8_path_prefix + "/third_party/inspector_protocol"
+_inspector_protocol = "../../../third_party/inspector_protocol"
 import("$_inspector_protocol/inspector_protocol.gni")
 
 _protocol_generated = [
@@ -97,8 +97,8 @@ v8_source_set("inspector") {
   deps = [
     ":inspector_string_conversions",
     "../..:v8_version",
-    "../../third_party/inspector_protocol:encoding",
-    "../../third_party/inspector_protocol:bindings",
+    "../../../third_party/inspector_protocol:encoding",
+    "../../../third_party/inspector_protocol:bindings",
   ]
 
   public_deps = [
--- a/v8/test/unittests/BUILD.gn
+++ b/v8/test/unittests/BUILD.gn
@@ -302,8 +302,6 @@ v8_source_set("unittests_sources") {
     "../..:v8_for_testing",
     "../..:v8_libbase",
     "../..:v8_libplatform",
-    "../../third_party/inspector_protocol:bindings_test",
-    "../../third_party/inspector_protocol:encoding_test",
     "//build/win:default_exe_manifest",
     "//testing/gmock",
     "//testing/gtest",
--- a/v8/src/inspector/inspector_protocol_config.json
+++ b/v8/src/inspector/inspector_protocol_config.json
@@ -47,10 +47,10 @@
     },
 
     "encoding_lib": {
-        "namespace": "v8_inspector_protocol_encoding"
+        "namespace": "inspector_protocol_encoding"
     },
 
     "bindings_lib": {
-        "namespace": "v8_inspector_protocol_bindings"
+        "namespace": "inspector_protocol_bindings"
     }
 }
--- a/v8/src/inspector/v8-inspector-protocol-encoding.cc
+++ b/v8/src/inspector/v8-inspector-protocol-encoding.cc
@@ -11,10 +11,10 @@
 
 namespace v8_inspector {
 namespace {
-using IPEStatus = ::v8_inspector_protocol_encoding::Status;
-using ::v8_inspector_protocol_encoding::span;
+using IPEStatus = inspector_protocol_encoding::Status;
+using inspector_protocol_encoding::span;
 
-class Platform : public ::v8_inspector_protocol_encoding::json::Platform {
+class Platform : public inspector_protocol_encoding::json::Platform {
  public:
   bool StrToD(const char* str, double* result) const override {
     *result = v8::internal::StringToDouble(str, v8::internal::NO_FLAGS);
--- a/v8/src/inspector/v8-inspector-protocol-encoding.h
+++ b/v8/src/inspector/v8-inspector-protocol-encoding.h
@@ -9,16 +9,16 @@
 
 namespace v8_inspector {
 
-::v8_inspector_protocol_encoding::Status ConvertCBORToJSON(
-    ::v8_inspector_protocol_encoding::span<uint8_t> cbor,
+inspector_protocol_encoding::Status ConvertCBORToJSON(
+    inspector_protocol_encoding::span<uint8_t> cbor,
     std::vector<uint8_t>* json);
 
-::v8_inspector_protocol_encoding::Status ConvertJSONToCBOR(
-    ::v8_inspector_protocol_encoding::span<uint8_t> json,
+inspector_protocol_encoding::Status ConvertJSONToCBOR(
+    inspector_protocol_encoding::span<uint8_t> json,
     std::vector<uint8_t>* cbor);
 
-::v8_inspector_protocol_encoding::Status ConvertJSONToCBOR(
-    ::v8_inspector_protocol_encoding::span<uint16_t> json,
+inspector_protocol_encoding::Status ConvertJSONToCBOR(
+    inspector_protocol_encoding::span<uint16_t> json,
     std::vector<uint8_t>* cbor);
 
 }  // namespace v8_inspector
--- a/v8/src/inspector/v8-inspector-session-impl.cc
+++ b/v8/src/inspector/v8-inspector-session-impl.cc
@@ -24,9 +24,9 @@
 
 namespace v8_inspector {
 namespace {
-using ::v8_inspector_protocol_encoding::span;
-using ::v8_inspector_protocol_encoding::SpanFrom;
-using IPEStatus = ::v8_inspector_protocol_encoding::Status;
+using inspector_protocol_encoding::span;
+using inspector_protocol_encoding::SpanFrom;
+using IPEStatus = inspector_protocol_encoding::Status;
 
 bool IsCBORMessage(const StringView& msg) {
   return msg.is8Bit() && msg.length() >= 2 && msg.characters8()[0] == 0xd8 &&
@@ -332,8 +332,8 @@ void V8InspectorSessionImpl::reportAllCo
 
 void V8InspectorSessionImpl::dispatchProtocolMessage(
     const StringView& message) {
-  using ::v8_inspector_protocol_encoding::span;
-  using ::v8_inspector_protocol_encoding::SpanFrom;
+  using inspector_protocol_encoding::span;
+  using inspector_protocol_encoding::SpanFrom;
   span<uint8_t> cbor;
   std::vector<uint8_t> converted_cbor;
   if (IsCBORMessage(message)) {
--- a/v8/third_party/inspector_protocol/encoding/encoding.cc
+++ b/v8/third_party/inspector_protocol/encoding/encoding.cc
@@ -11,7 +11,7 @@
 #include <limits>
 #include <stack>
 
-namespace v8_inspector_protocol_encoding {
+namespace inspector_protocol_encoding {
 // =============================================================================
 // Status and Error codes
 // =============================================================================
@@ -2231,4 +2231,4 @@ Status ConvertJSONToCBOR(const Platform&
   return ConvertJSONToCBORTmpl(platform, json, cbor);
 }
 }  // namespace json
-}  // namespace v8_inspector_protocol_encoding
+}  // namespace inspector_protocol_encoding
--- a/v8/third_party/inspector_protocol/encoding/encoding.h
+++ b/v8/third_party/inspector_protocol/encoding/encoding.h
@@ -14,7 +14,7 @@
 #include <string>
 #include <vector>
 
-namespace v8_inspector_protocol_encoding {
+namespace inspector_protocol_encoding {
 // This library is designed to be portable. The only allowed dependency
 // are the C/C++ standard libraries, up to C++11. We support both 32 bit
 // and 64 architectures.
@@ -537,6 +537,6 @@ Status ConvertJSONToCBOR(const Platform&
                          span<uint16_t> json,
                          std::string* cbor);
 }  // namespace json
-}  // namespace v8_inspector_protocol_encoding
+}  // namespace inspector_protocol_encoding
 
 #endif  // V8_INSPECTOR_PROTOCOL_ENCODING_ENCODING_H_
--- a/v8/third_party/inspector_protocol/encoding/encoding_test.cc
+++ b/v8/third_party/inspector_protocol/encoding/encoding_test.cc
@@ -18,7 +18,7 @@
 
 using testing::ElementsAreArray;
 
-namespace v8_inspector_protocol_encoding {
+namespace inspector_protocol_encoding {
 
 class TestPlatform : public json::Platform {
   bool StrToD(const char* str, double* result) const override {
@@ -2044,4 +2044,4 @@ TYPED_TEST(ConvertJSONToCBORTest, RoundT
   EXPECT_EQ(expected_json, roundtrip_json);
 }
 }  // namespace json
-}  // namespace v8_inspector_protocol_encoding
+}  // namespace inspector_protocol_encoding
--- a/v8/third_party/inspector_protocol/encoding/encoding_test_helper.h
+++ b/v8/third_party/inspector_protocol/encoding/encoding_test_helper.h
@@ -16,7 +16,7 @@
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace v8_inspector_protocol_encoding {
+namespace inspector_protocol_encoding {
 
 std::string UTF16ToUTF8(span<uint16_t> in) {
   return v8_inspector::UTF16ToUTF8(in.data(), in.size());
@@ -28,6 +28,6 @@ std::vector<uint16_t> UTF8ToUTF16(span<u
   return std::vector<uint16_t>(utf16.begin(), utf16.end());
 }
 
-}  // namespace v8_inspector_protocol_encoding
+}  // namespace inspector_protocol_encoding
 
 #endif  // V8_INSPECTOR_PROTOCOL_ENCODING_ENCODING_TEST_HELPER_H_
